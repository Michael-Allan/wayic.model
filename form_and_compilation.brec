Form and compilation of way models

    - A way model is a waycast in compiled, executable form,
      as opposed to the initial, written form of its source code.
        : cf. `^^ Simulacrum$` @ http://reluk.ca/project/Breccia/language_definition.brec
        - A representation of an aimed way of life.
        - A Waybreccian simulacrum.
    - It comprises a directory of files together with a data store, each file either originating
      in the waycast, lying on-way of it, or otherwise subsumed.
    - It results from compiling the waycast.
        : re `compiling` see `^^ Compilation$`



    ━━━━━━━━━━━━━
     Compilation
    ─────────────
        : cf. @ http://reluk.ca/project/Breccia/language_definition.brec
        - Compilation of a way model from a waycast.

        compile( waycast `w` )
            : join `^^simulacral reference$` @ `^^ Note$`
            0. Initialization
                if( `w` contains at its base a file or directory named `:` )
                    throw+ Disallowed file name
                + Add to the model all files of `w`.
            1. Subsumption
                a) Files explicitly subsumed \ Before (b), wherefore no subsumer `s` is remote.
                    for( each subsumer `s` of the model  )
                        + `subsume referent( URI of s )`
                            : see `^^subsume referent\(` @ `^^ Subsumption$`
                b) Files lying on-way
                    deem+ `t` a thoroughfractum, that of the model
                    if( `t` is a jointer `j` )
                        + `subsume through( j )`
                            : see `^^subsume through\(` @ `^^ Subsumption$`
                    else
                        + `subsume subjoints( t )`
                            : see `^^subsume subjoints\(` @ `^^ Subsumption$`
                c) References
                    / Those not subsumed en passent in (b).
                    for( each associative reference `rA` of the model  )
                        if( `rA` has a resource indicant `iR`,
                          & `iR` has neither a `non-fractal` nor an `unsubsumed` qualifier,
                          & the URI reference of `iR` is a proper URI `u` )
                            : re `proper URI` see https://tools.ietf.org/html/rfc3986#section-3
                            deem+ `p` a file path, that of `subsumed path( u )`
                            if( `p` is not null )
                                + `subsume reference( rA, u, p )`
            2. Patching
            3. Compilation

        order by path( list of file paths `pp` )
            + Sort `pp` into lexicographic order based on Unicode code points.
            return+ `pp`



    ━━━━━━━━━━━━
     Data store
    ────────────
        loose references
            - The set of associative references each of which failed to subsume because its referent
              could not be found in the subsumed instance of the referent file.
                / This may occur, for instance, when conflict resolution has pre-emptively disabled
                  one or more patches that would have applied to subsumed instance of the referent file.
            / The corresponding referents, lying outside the way model, are off-way by definition.



    ━━━━━━━━━━━━
     Subsumption
    ────────────
        - All extracast files of a way model are copied and stored within the model (subsumed)
          at a path formed as follows.

              ╶──╴‘:/’╶── authority ── path ───▶

                : re `authority` see https://tools.ietf.org/html/rfc3986#section-3.2
                : re `path` see https://tools.ietf.org/html/rfc3986#section-3.3
            - The authority and path components of the subsumed file
              are those of its canonical location as expressed in URI form.
                : re `URI form` see https://tools.ietf.org/html/rfc3986#section-3
            / Omitted is the scheme component of the canonical location, which compilers and other
              processors may recover ad hoc through a process of trial and error discovery.
        - Subsumption serves several purposes, which include the following.
            • Collation of the way model from scattered waysource.
            • Patching of waysource that would otherwise be out of reach.
            • Ease of surjoining remote way models, or otherwise referring into them.
                : see `^^- A public way model .+ to which other waysource may refer\.$`
        - Regardless of the various forms of reference to an extracast file, whether to its original
          or a remote subsumption of it (any number of which may be combined in the waysource), the way
          model has at most one, locally subsumed instance of the file to which all such references
          (where not precluded by model divergence) are themselves subsumed by transformation.
            : re `locally subsumed instance` see `^^subsumed path\( URI`
            : re `precluded by model divergence` see `^^warn.+Loose reference:.+\R.+left unsubsumed`
        - A public way model includes its subsumptions, to which other waysource may refer.
            / The following, for example, refers to a publicly subsumed file.
              http://reluk.ca/project/waycast/:/cleo.abacus.au/walt/waycast/foo.brec
            - The referent, in that case, would be the file as seen in the subsuming way model (M).
                / E.g. `https://cleo.abacus.au/walt/waycast/foo.brec`
                  as seen in `http://reluk.ca/project/waycast/`.
            - Compiling a jointer to such a referent would subsume the file from its original waycast,
              while applying (where conflict resolution allows) the patches of M.

        standardize( URI `u` )
            : re `URI` see https://tools.ietf.org/html/rfc3986#section-3
            / Returns the standard form of `u` for subsumption purposes.
            if( `u` lacks an authority component )
                throw+ Malformed reference
            if( `u` refers to a waycast file )
                + Set `u` to `canonicalize( u )`.
                    : re `canonicalize` see `canonicalize\( URI` @ `^^ Canonical location$` @
                      http://reluk.ca/project/wayic/cast/form_of_a_waycast.brec
            else
                + Set `u` to normal form.
                    : see https://tools.ietf.org/html/rfc3986#section-6
            return+ `u`

        subsumed path( URI `u` )
            : re `URI` see https://tools.ietf.org/html/rfc3986#section-3
            / The path to the subsumed instance of the referent of `u`, or null if none is subsumed.
                : re `subsumed instance` see @ `^^- Regardless of the various forms of reference`
            deem+ `v` a URI, that of `standardize( u )`
                  `p` the subsumption path derived from `u`
                : re `subsumption path` see `are .+subsumed.+ at a path formed as follows`
            if( `p` is  absent from the way model )
                + Set `p` to null.
            return+ `p`

        subsume reference( subsumable associative reference `rA` of the model,
              URI `u` equal to the URI reference of the resource indicator of `rA`,
              path `p` of the subsumed instance of the file at `u` )
                : re `(URI) \`u\`` see https://tools.ietf.org/html/rfc3986#section-3
            / Transforms `rA` to refer instead to the subsumed instance of its original referent,
              then writes the transformed result back into the model.
            / Returns `(rA, wasSubsumed)`, the resulting associative reference `rA` plus boolean flag
              `wasSubsumed`.  The flag will be false if subsumption failed, in which case `rA` will have
              been added to the data store’s loose references and will retain its original form.
            deem+ `wasSubsumed` a boolean flag, initially false
            if( `rA` is absent from the loose references of the data store )
                + Transform `rA` by setting its resource indicator’s URI reference (presently `u`)
                  to the relative path from the file of `rA` to that of `p`.
                try
                    + `referent( rA )`
                        : see `^^referent\( associative reference \)` @
                          http://reluk.ca/project/Breccia/language_definition.brec
                    + Write `rA` back into the model, replacing its original instance.
                    + Set `wasSubsumed` to true.
                catch( broken reference, pattern not found )
                    + Revert `rA` to its original form by setting its resource indicator’s
                      URI reference back to `u`.
                    + Add `rA` to the loose references of the data store.
                    + Warn of `(rA, u)`, ‘Loose reference `rA`: its referent could not be found
                      in the subsumed instance of its referent file `u`, and therefore `rA`
                      is left unsubsumed, referring outside the way model.’
            return+ `(rA, wasSubsumed)`

        subsume referent( URI `u` )
            : re `URI` see https://tools.ietf.org/html/rfc3986#section-3
            / Subsumes the referent of `u` unless already it was subsumed.
            + Set `u` to `standardize( u )`.
            deem+ `p` the subsumption path derived from `u`
                : re `subsumption path` see `are .+subsumed.+ at a path formed as follows`
            if( `p` is  absent from the way model )
                + Copy the referent of `u` to `p`.
                for( each relative URI reference `r` in the copy )
                    + Replace `r` with an absolute reference, that of `r` resolved against `u`.
            return+ `p`

        subsume subjoints( fractum `f` of the model )
            / Ensures that the subsumable files of all fracta subjoint of `f` are subsumed.
            for( each jointer `j` descendent of `f` )
                + `subsume through( j )`
                    / Here compilers should detect and avoid any infinite loop.

        subsume through( jointer `j` of the model )
            / Ensures that the subsumable files of all fracta subjoint through `j` are subsumed.
            if( `j` has a resource indicant `iR` )
                if( `iR` has either a `non-fractal` or an `unsubsumed` qualifier )
                    return+
                if( the URI reference of `iR` is a proper URI `u` )
                    : re `proper URI` see https://tools.ietf.org/html/rfc3986#section-3
                    deem+ `wasSubsumed` a boolean flag;
                          `p` the path of a subsumed file
                    + Set `p` to `subsume referent( u )`.
                    + Set `(j, wasSubsumed)` to `subsume reference( j, u, p )`.
                    unless( wasSubsumed )
                        return+
            deem+ `f` a fractum;
                  `t` a referent
            + Set `t` to `referent( j )`.
                : re `referent` see `^^referent\( associative reference \)` @
                  http://reluk.ca/project/Breccia/language_definition.brec
            if( `t` is a fractal-head text sequence )
                + Set `f` to the fractum of the head in which `t` occurs.
            else
                / Then `t` can only be a fractum. \ ∵ `non-fractal` is absent
                + Set `f` to `t`.
            / Fractum `f` lies within the model. \ ∵ any `u` above was subsumed to a relative reference
            + `subsume subjoints( f )`



    ━━━━━━
     Note
    ──────
        simulacral reference
            - Herein the default referent is the simulacrum (aka the way model), not the source code.
                : cf. `^^default referent` @ `^^ Simulacrum$` @
                  http://reluk.ca/project/Breccia/language_definition.brec



                                                    \ Copyright © 2020-2021  Michael Allan.  Licence MIT.
