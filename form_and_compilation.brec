Form and compilation of way models

    - A way model is a waycast in compiled, executable form,
      as opposed to the initial, written form of its source code.
        : cf. `^^ Simulacrum$` @ http://reluk.ca/project/Breccia/language_definition.brec
        - A representation of an aimed way of life.
        - A Waybreccian simulacrum.
    - It comprises a compiled directory of files, each originating either in the waycast
      or elsewhere subjoint of it.
    - It results from compiling the waycast.
        : re `compiling` see `^^ Compilation$`



    ━━━━━━━━━━━━━
     Compilation
    ─────────────
        : cf. @ http://reluk.ca/project/Breccia/language_definition.brec
        - Compilation of a way model from a waycast.

        compile( waycast `w` )
            : join `^^simulacral reference$` @ `^^ Note$`
            deem+ `m` a way model
            0. Initialization
                if( `w` contains at its base a file or directory named `:` )
                    throw+ Disallowed file name
                + Add to `m` all files of `w`.
            1. Subsumption
            2. Patching
            3. Compilation
                for( each file `f` of `order by path`( all files of `m` ))
                    : cf. `^^compile( Breccian file` @
                      http://reluk.ca/project/Breccia/language_definition.brec
                    for( each associative reference `rA` of `f` in linear order )
                        / Compiled early, associative references find their referents in the way model
                          before its transformation in later compilations.
                        deem+ `uP` a URI, initially null;
                              `iR` any resource indicant of `rA`;
                              `p` a file path, that of an subsumed file
                        if( `iR` is present and without an `unsubsumed` qualifier )
                            deem+ `u` the URI reference of `iR`
                            if( `u` is a URI )
                                : re `URI ` see https://tools.ietf.org/html/rfc3986#section-3
                                + Set `p` to `subsumed path( u )`.
                                if( `p` is not null )
                                    + Set `uP` to `u`.
                                    + Rebase `u` to `p`.
                                    + Rewrite the URI reference of `iR`, changing it to `u`.
                        try
                            + `compile( rA )`
                                : join `^^compile( associative reference )$` @
                                  http://reluk.ca/project/Breccia/language_definition.brec
                        catch( `x`: broken reference, pattern not found )
                            if( `uP` is not null )
                                + Rewrite the URI reference of `iR`, changing it back to `uP`.
                                + `compile( rA )`
                                + Warn ‘Loose reference: its referent unfound in the patched waysource
                                  of `p`, it is left unsubsumed, referring outside the way model.’
                                    / This may occur, for instance, when conflict resolution has
                                      pre-emptively disabled one or more extracast patches.
                                    / Such a referent, lying outside the way model, is always off-way.

        order by path( list of file paths `pp` )
            + Sort `pp` into lexicographic order based on Unicode code points.
            return+ `pp`



    ━━━━━━━━━━━━
     Subsumption
    ────────────
        - All extracast files of a way model are copied and stored within the model (subsumed)
          at a path formed as follows.

              ╶──╴‘:/’╶── authority ── path ───▶

                : re `authority` see https://tools.ietf.org/html/rfc3986#section-3.2
                : re `path` see https://tools.ietf.org/html/rfc3986#section-3.3
            - The authority and path components of the subsumed file
              are those of its canonical location as expressed in URI form.
                : re `URI form` see https://tools.ietf.org/html/rfc3986#section-3
            / Omitted is the scheme component of the canonical location, which compilers and other
              processors may recover ad hoc through a process of trial and error discovery.
        - Subsumption serves several purposes, which include the following.
            • Collation within the way model of its referential parts.
                : cf. `a referent.* outside the way model, is always off-way$` @ `^^ Compilation$`
            • Patching of referent files.
            • Ease of reference formation.
                : see `^^- A public way model .+ to which other waysource may refer\.$`
        - Regardless of the various forms of reference to an extracast file, whether to its original
          or a remote subsumption of it (any number of which may be combined in the waysource), the way
          model has at most one, locally subsumed instance of the file to which all such references
          (where not precluded by model divergence) are themselves subsumed by transformation.
            : re `locally subsumed instance` see `^^subsumed path\( URI`
            : re `precluded by model divergence` see `^^warn.+Loose reference:.+\R.+left unsubsumed`
        - A public way model includes its subsumptions, to which other waysource may refer.
            / The following, for example, refers to a publicly subsumed file.
              http://reluk.ca/project/waycast/:/cleo.abacus.au/walt/waycast/foo.brec
            - The referent, in that case, would be the file as seen in the subsuming way model (M).
                / E.g. `https://cleo.abacus.au/walt/waycast/foo.brec`
                  as seen in `http://reluk.ca/project/waycast/`.
            - Compiling a jointer to such a referent would subsume the file from its original waycast,
              while applying (where conflict resolution allows) the patches of M.

        subsumed path( URI `u` )
            / The path to the subsumed instance of the referent of `u`, or null if none is subsumed.
                : re `subsumed instance` see @ `^^- Regardless of the various forms of reference`
            deem+ `v` a URI, that of `standardize( u )`
                  `p` the subsumption path derived from `u`
                : re `subsumption path` see `are .+subsumed.+ at a path formed as follows`
            if( `p` is  absent from the way model )
                + Set `p` to null.
            return+ `p`
        subsume referent( URI `u` )
            / Subsumes the referent of the given URI, unless already it was subsumed.
            + Set `u` to `standardize( u )`.
            deem+ `p` the subsumption path derived from `u`
                : re `subsumption path` see `are .+subsumed.+ at a path formed as follows`
            if( `p` is  absent from the way model )
                + Copy the referent of `u` to `p`.
                for( each relative reference `r` in the copy )
                    + Replace `r` with an absolute reference, that of `r` resolved against `u`.
        standardize( URI `u` )
            / Returns the standard form of `u` for subsumption purposes.
            if( `u` lacks an authority component )
                throw+ Malformed reference
            if( `u` refers to a waycast file )
                + Set `u` to `canonicalize( u )`.
                    : re `canonicalize` see `canonicalize\( URI` @ `^^ Canonical location$` @
                      http://reluk.ca/project/wayic/cast/form_of_a_waycast.brec
            else
                + Set `u` to normal form.
                    : see https://tools.ietf.org/html/rfc3986#section-6
            return+ `u`



    ━━━━━━
     Note
    ──────
        simulacral reference
            - Herein the default referent is the simulacrum (aka the way model), not the source code.
                : cf. `^^default referent` @ `^^ Simulacrum$` @
                  http://reluk.ca/project/Breccia/language_definition.brec



                                                    \ Copyright © 2020-2021  Michael Allan.  Licence MIT.
