Form and compilation of way models

    - A way model is the compiled, executable form of a waycast,
      as opposed to the initial, written form of its source code.
        : cf. `^^ Simulacrum$` @ http://reluk.ca/project/Breccia/language_definition.brec
        - A representation of an aimed way of life.
        - A Waybreccian simulacrum.
    - It comprises a directory of files together with a data store, each file either originating
      in the waycast, lying on-way of it, or otherwise subsumed.
    - It results from compiling the waycast.
        : re `compiling` see `^^ Compilation$`



    ━━━━━━━━━━━━━
     Compilation
    ─────────────
        : cf. @ http://reluk.ca/project/Breccia/language_definition.brec
        - Compilation of a way model from a waycast.

        compile( waycast `w` )
            1. Copying of intracast files
                if( `w` contains at its base a file or directory named `:` )
                    throw+ Disallowed file name
                + Add to the model all files of `w`.
            2. Registration of subcasts
                deem+ `λ` the canonical location of the local waycast
                + Add `λ` to `λλ`.
                + Set the `local waycast register` of the data store
                  to `make register( local waycast, λ )`.
            3. Subsumption and patching of extracast files
                a) Explicitly via subsumers \ Before (b), while the model contains local subsumers only.
                    for( each subsumer `s` of the model  )
                        + `subsume and patch referent( URI of s )`
                            : see `^^subsume and patch referent\(` @ `^^ Subsumption$`
                b) Implicitly via way trace
                    deem+ `t` a thoroughfractum, that of the model
                    if( `t` is a jointer `j` )
                        + `subsume and patch through( j )`
                            : see `^^subsume and patch through\(` @ `^^ Subsumption$`
                    else
                        + `subsume and patch subjoints( t )`
                            : see `^^subsume and patch subjoints\(` @ `^^ Subsumption$`
            4. Internment of references
                : see also `(intern reference)` @ `^^subsume and patch through`
                for( each associative reference `rA` of the model  )
                    if( `rA` has a resource indicant `iR`,
                      & `iR` is without an `uninterned` qualifier,
                      & the URI reference of `iR` is a proper URI `u` )
                        : re `proper URI` see https://tools.ietf.org/html/rfc3986#section-3
                        deem+ `p` a file path, that of `intramodel path( standardize( u ))`
                        if( a file is present at `p` )
                            + `intern reference( rA, u, p )`
            5. Compilation

        intern reference( internable associative reference `rA` of the model,
              URI `u` equal to the URI reference of the resource indicator of `rA`,
              path `p` of the intramodel instance of the referent of `u` )
                : re `(URI) \`u\`` see https://tools.ietf.org/html/rfc3986#section-3
            / Transforms `rA` to refer instead to `p`, then writes `rA` back into the model.
              Returns `(rA, wasInterned)`, the resulting associative reference `rA` plus boolean flag
              `wasInterned`.  The flag will be false if internment failed, in which case `rA` will have
              been added to the data store’s stray references and will retain its original form.
            deem+ `wasInterned` a boolean flag, initially false
            if( `p` is no subsumption path )
                : re `subsumption path` see `are .+subsumed.+ at a path formed as follows`
                + Transform `rA` by setting its resource indicator’s URI reference (presently `u`)
                  to the relative path from the file of `rA` to that of `p`. \ The same as below.
                + Write the transformed `rA` into the model, replacing its original instance.
                + Set `wasInterned` to true.
            else if( `rA` is absent from the stray references of the data store )
                + Transform `rA` by setting its resource indicator’s URI reference (presently `u`)
                  to the relative path from the file of `rA` to that of `p`. \ The same as above.
                try
                    + `referent( rA )`
                        : see `^^referent\( associative reference \)` @
                          http://reluk.ca/project/Breccia/language_definition.brec
                    + Write the transformed `rA` into the model, replacing its original instance.
                    + Set `wasInterned` to true.
                catch( broken reference, pattern not found )
                    + Revert `rA` to its original form by setting its resource indicator’s
                      URI reference back to `u`.
                    + Add `rA` to the stray references of the data store.
                    + Warn of `(rA, u)`, ‘Stray reference `rA`: its referent could not be found
                      in the subsumed instance of its referent file `u`, and therefore `rA`
                      is left uninterned, referring outside the way model.’
            return+ `(rA, wasInterned)`

        intramodel path( standardized URI `u` )
            : re `standardized` see `^^standardized\(`
            : re `URI` see https://tools.ietf.org/html/rfc3986#section-3
            / The path proper to any intramodel instance of the referent of `u`.
                : re `intramodel instance` see @ `^^- Regardless of the various forms of reference`
            if( `u` begins with the canonical location `λ` of the local waycast )
                return+ `u` relativized against `λ`
            return+ the subsumption path derived from `u`
                : re `subsumption path` see `are .+subsumed.+ at a path formed as follows`

        make register( waycast `w`, waycast canonical location `λ` )
            / Makes a complete waycast register for `w`.  Assumes that already `λλ` contains `λ`.
            deem+ `r` a new waycast register
            + Set the `location` of `r` to `λ`.
            for( each subcast `s` of `w` in priority order )
                + Set `λ` to the canonical location of `s`.
                unless( `λλ` contains `λ` )
                    + Add `λ` to `λλ`.
                    + Append `make register(s,λ)` to the `subcast registers` of `r`.
            return+ `r`

        standardize( URI `u` )
            : re `URI` see https://tools.ietf.org/html/rfc3986#section-3
            / Returns the standard form of `u` for subsumption purposes.
            if( `u` lacks an authority component )
                throw+ Malformed reference
            if( `u` refers to a waycast file )
                + Set `u` to `canonicalize( u )`.
                    : re `canonicalize` see `canonicalize\( URI` @ `^^ Canonical location$` @
                      http://reluk.ca/project/wayic/cast/form_of_a_waycast.brec
            else
                + Set `u` to normal form.
                    : see https://tools.ietf.org/html/rfc3986#section-6
            return+ `u`



    ━━━━━━━━━━━━
     Data store
    ────────────
        λλ
            - The set of canonical locations of registered waycasts.
                : see `^^location` @ `^^waycast register$`
        local waycast register
            - The waycast register of the local waycast.
            / Initial value, null.
        stray references
            - The set of associative references each of which retains its original, uninterned form
              only because an internment attempt had failed to find its referent
              in the subsumed instance of the referent file.
                / E.g. because patches targeting the referent file have been suppressed.
                / Initial value, empty.
            / The corresponding referents, lying outside the way model, are off-way by definition.



    ━━━━━━━━━━━━━━━━
     Data structure
    ────────────────
        waycast register
            - The register of a waycast `w`.
            - It defines the hierarchic order of waycasts (surcasts and subcasts)
              that in turn governs the order of patch application.
            location, URI
                - The canonical location of `w`.
                : re `URI` see https://tools.ietf.org/html/rfc3986#section-3
                / Initial value, null.
                - All locations within the register, including that of `w` and each of its subcasts,
                  whether direct or indirect, are unique.
            subcast registers, list of waycast registers
                - The registers of the subcasts of `w` in priority order, highest first.
                / Initial value, empty.



    ━━━━━━━━━━━━━━━━━━━
     Patch application
    ───────────────────
        - Each file is patched immediately on its subsumption.
        - Patches are applied to the file in a hierarchic order derived from the waycast registers `wR`,
          beginning with that of the local waycast.
            : re `that of the local waycast` see `^^local waycast register$`
            a) First to apply are the patches of the subcast registers of `wR`.
                : see `^^subcast registers` @ `^^waycast register$`
            b) Last to apply are the patches of the `wR` waycast itself.
        - This order recurses at step (a), wherein both steps (a, b) repeat for each subcast register
          (itself now `wR`) in turn.
            / In terms of tree structures, this is a depth-first post-order traversal.

        apply patches( subsumed path `t` of the target file,  waycast `w` )
            for( each Breccian file `f` of `w` in standard path order )
                for( each patch `p` of `f` in linear order )
                    if( the target of `p` has the same canonical location as the original of `t` )
                        : see `The.+components of the subsumed file.+are.+of its canonical location`
                          @ `^^ Subsumption$`
                        + `apply( p, t )`
                            : see `^^apply\(` @ `^^ Patch$` @
                              http://reluk.ca/project/wayic/Waybrec/language_definition.brec

        apply patches( subsumed path `t` of the target file,  waycast `w`,  waycast register `wR` )
            / Returns true if target `t` is native to `w` or a registered subcast of `w`.
            deem+ `isSelfOwned` a boolean flag telling whether `t` is native to `w`;
                  `isRegistrantOwned` a boolean flag, initially false, to tell whether `t`
                     is native to `w` or a registered subcast of `w`;
                  `cS` a cause of patch suppression, initially null
            a) Patches of the registered subcasts of `w`
                if( `isSelfOwned` )
                    + Set `isRegistrantOwned` to true.
                    + Set `cS` to `surcast targeting`.
                for( each waycast register `sR` of the `subcast registers` of `wR` )
                    deem+ `s` the waycast at `sR.location`
                    if( `cS` is null )
                        + Set `isRegistrantOwned` to `apply patches( t, s, sR )`.
                        if( `isRegistrantOwned` )
                            + Set `cS` to `prior-branch targeting`.
                    else
                        + `record suppression of any patches( t, s, cS, sR )`
            b) Patches of `w` itself
                if( not `isSelfOwned` )
                    if( `isRegistrantOwned` )
                        + `apply patches( t, w )`
                    else \ [native dormancy], q.v. at end note
                        + `record suppression of any patches( t, w, native dormancy )`
                            : re `native dormancy` see `^^determination of native dormancy` @ `^^ Note$`
                else
                    + `record suppression of any patches( t, w, self targeting )`
            return+ `isRegistrantOwned`

        standard path order
            - An arrangement among file paths determined by applying the Unicode Collation Algorithm
              to their string representations.
                : re `^^Unicode Collation Algorithm$` see https://unicode.org/reports/tr10/
                : re `^^Unicode Collation Algorithm$` e.g. http://site.icu-project.org/
            - How to apply this algorithm (e.g. language and other customizations) is yet undefined.
                / It may require formalizing a locale property for the waycast.


        ───────────────────
         patch suppression
        ┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈
            - The application of a patch may be suppressed owing to one of several causes,
              which are formalized as follows.

                `native dormancy`
                    - The patch has no effect in the model of its native waycast,
                      because there its target is unsubsumed.
                        : see `Patches whose targets fall within the way model alone are applied` @
                          http://reluk.ca/project/wayic/Waybrec/language_definition.brec
                    - Likely it was subsumed in the past, then disappeared and left the patch
                      lying dormant there, its target now out of reach.
                    - The target reappears here in the present model, but rather than activate and apply
                      to it a patch which has lain dormant and probably unmaintained in its native model,
                      the patch is here suppressed.
                `prior-branch targeting`
                    - The patch targets a file native to a waycast registered in a prior branch
                      of the register hierarchy.
                    - A surcast has registered the present branch at a lower priority.
                        - Typically this occurs when the surcaster has surjoined a new subcast
                          and must therefore assign it a priority.
                        - Often he assigns a lower priority in the hope of gaining from the subcast
                          what he sees in it, while suffering no unexpected (and often unseen) loss
                          as a side effect of its patches.
                    - For this reason the patch is suppressed by default.
                      It targets a file which the surcaster may prefer to leave unaltered.
                `self targeting`
                    - The patch targets a file of its own waycast.
                    - This causes a compilation error, in fact, not a patch suppression.
                        / It is included here only because of its similarity
                          to the other ‘targeting’ causes.
                        : re `compilation error` e.g. `^^throw. Patch.+ targets.+its own waycast` @
                          `^^record suppression of patch\($`
                `surcast targeting`
                    - The patch targets a file native to a surcast.
                    - For this reason the patch is suppressed by default.  It targets a file which
                      the surcaster may prefer to leave unaltered, especially without prior notice.

            record suppression of any patches( subsumed path `t` of the target file,  waycast `w`,
                      cause of suppression `cS` )
                for( each Breccian file `f` of `w` in standard path order )
                    for( each patch `p` of `f` in linear order )
                        if( the target of `p` has the same canonical location as the original of `t` )
                            : see `The.+components of the subsumed file.+are.+of its canonical location`
                              @ `^^ Subsumption$`
                            + `record record suppression of patch( t, w, cS, p )`

            record suppression of any patches( subsumed path `t` of the target file,  waycast `w`,
                      cause of suppression `cS`, waycast register `wR` )
                a) Patches of the registered subcasts of `w`
                    for( each waycast register `sR` of the `subcast registers` of `wR` )
                        deem+ `s` the waycast at `sR.location`
                        + `record suppression of any patches( t, s, cS, sR )`
                b) Patches of `w` itself
                    + `record suppression of any patches( t, w, cS )`

            record suppression of patch( subsumed path `t` of the target file,  waycast `w`,
                      cause of suppression `cS`, patch `p` )
                if( `cS` equals `self targeting` )
                    throw+ Patch `p` targets file `t` of its own waycast `w`
                        : see `target must lie.+remote` @ `^^ Patch$` @
                          http://reluk.ca/project/wayic/Waybrec/language_definition.brec
                + Record for the user a message that the application of patch `p` native of `w`
                  to target `t` has been suppressed owing to cause `cS`.
                    / Compilers may include further data (e.g. attached to `cS`)
                      in order to form a message helpful to the user.



    ━━━━━━━━━━━━━
     Subsumption
    ─────────────
        - All extracast files of a way model are copied and stored within the model (subsumed)
          at a path formed as follows.

              ╶──╴‘:/’╶── authority ── path ───▶

                : re `authority` see https://tools.ietf.org/html/rfc3986#section-3.2
                : re `path` see https://tools.ietf.org/html/rfc3986#section-3.3
            - The authority and path components of the subsumed file
              are those of its canonical location as expressed in URI form.
                : re `URI form` see https://tools.ietf.org/html/rfc3986#section-3
            / Omitted is the scheme component of the canonical location, which compilers and other
              processors may recover ad hoc through a process of trial and error discovery.
        - Subsumption serves several purposes, which include the following.
            • Collation of the way model from scattered waysource.
            • Patching of waysource that would otherwise be out of reach.
            • Ease of surjoining remote way models, or otherwise referring into them.
                : see `^^- A public way model .+ to which other waysource may refer\.$`
        - Regardless of the various forms of reference to an extracast file, whether to its original
          or a remote subsumption of it (any number of which may be combined in the waysource),
          the way model has at most one, intramodel instance of the file to which all such references
          (where not precluded by model divergence) are transformed (interned).
            : re `intramodel instance` see `^^intramodel path\(` @ `^^ Compilation$`
            : re `precluded by model divergence` see `^^stray references$` @ `^^ Data store$`
        - A public way model includes its subsumptions, to which other waysource may refer.
            / The following, for example, refers to a publicly subsumed file.
              http://reluk.ca/project/waycast/:/cleo.abacus.au/walt/waycast/foo.brec
            - The referent, in that case, would be the file as seen in the subsuming way model (M).
                / E.g. `https://cleo.abacus.au/walt/waycast/foo.brec`
                  as seen in `http://reluk.ca/project/waycast/`.
            - Compiling a jointer to such a referent would subsume the file from its native waycast,
              and apply to it (subject to patch suppression) not only the patches of its native model,
              but additionally those of M.

        subsume and patch referent( URI `u` )
            : re `URI` see https://tools.ietf.org/html/rfc3986#section-3
            / Subsumes and patches the referent of `u` unless it is proper to the waycast
              or was already subsumed.  Returns the value of `intramodel path( u )`.
                : re `intramodel path` see `^^intramodel path\(` @ `^^ Compilation$`
            deem+ `v` a standardized URI, that of `standardize( u )`;
                  `f` a file path, that of `intramodel path( v )`
                : see `^^standardized\(` @ `^^ Compilation$`
                : see `^^intramodel path\(` @ `^^ Compilation$`
            if( `f` is a subsumption path  &  no file is present at `f` )
                : re `subsumption path` see `are .+subsumed.+ at a path formed as follows`
                if( `v` refers to a waycast file )
                    deem+ `λ` the waycast location of `v`
                    unless( `λλ` contains `λ` )
                        throw+ Attempt to subsume file `u` native of waycast `λ`,
                          unregistered as a subcast
                + Copy the referent of `u` to `f`.
                for( each relative URI reference `r` in the copy )
                    + Replace `r` with an absolute reference, that of `r` resolved against `u`.
                + `apply patches( f, local waycast, local waycast register )`
                    : see `^^apply patches\( subsumed file path.+waycast register` @
                      `^^ Patch application$`
            return+ `f`

        subsume and patch subjoints( fractum `f` of the model )
            / Ensures that the subsumable files of all fracta subjoint of `f` are subsumed and patched.
            for( each jointer `j` descendent of `f` )
                + `subsume and patch through( j )`
                    / Here compilers should detect and avoid any infinite loop.

        subsume and patch through( jointer `j` of the model )
            / Ensures that the files of all fracta subjoint and subsumable by way of `j`
              are indeed subsumed and patched.
            if( `j` has a resource indicant `iR` )
                if( `iR` has either a `non-fractal` or an `uninterned` qualifier )
                    return+
                if( the URI reference of `iR` is a proper URI `u` )
                    : re `proper URI` see https://tools.ietf.org/html/rfc3986#section-3
                    deem+ `p` a file path;
                          `wasInterned` a boolean flag
                    + Set `p` to `subsume and patch referent( u )`.
                    + Set `(j, wasInterned)` to `intern reference( j, u, p )`.
                        : see `^^intern reference\(` @ `^^ Compilation$`
                    unless( wasInterned )
                        return+
            deem+ `f` a fractum;
                  `t` a referent
            + Set `t` to `referent( j )`.
                : re `referent` see `^^referent\( associative reference \)` @
                  http://reluk.ca/project/Breccia/language_definition.brec
            if( `t` is a fractal-head text sequence )
                + Set `f` to the fractum of the head in which `t` occurs.
            else
                / Then `t` can only be a fractum. \ ∵ `non-fractal` is absent
                + Set `f` to `t`.
            / Fractum `f` lies within the model. \ ∵ any `u` above was subsumed to a relative reference
            + `subsume and patch subjoints( f )`



    ━━━━━━
     Note
    ──────
        determination of native dormancy
            - No registered subcast of `w` owns target file `t` in the present model.
                ∵ `isRegistrantOwned` is false.
            ∴ No registered subcast in the model of `w` owns `t`.
                ∵ Otherwise, in the present model, that subcast (here unregistered for `w`) must instead
                  be registered for a surcast or waycast of a prior branch of the register hierarchy,
                  in which case this point in the compilation process would never have been reached.
                    ∵ Rather than `apply patches` of `w`, the compiler would have suppressed their
                      application for the cause of `surcast targeting` or `prior-branch targeting`.
            ∴ File `t` in the model of `w` would be unsubsumed.
                ∵ Subsumption of any file depends on its native waycast being registered as a subcast.
                    : see `^^throw.+native of waycast.+\N.+unregistered as a subcast$` @
                      `^^subsume and patch referent\(`
            ∴ The model of `w` would apply to `t` no patch.
            ∴ The model of `w` would apply to `t` no patch declared by `w`.
              Such a patch would, in other words, lie dormant in its native model.
            ∴ Application of all such patches is here suppressed for the cause of `native dormancy`.



                                                    \ Copyright © 2020-2021  Michael Allan.  Licence MIT.
