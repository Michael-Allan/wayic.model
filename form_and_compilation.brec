Form and compilation of way models

    - A way model is the compiled, executable form of a waycast,
      as opposed to the initial, written form of its source code.
        : cf. `^^ Simulacrum$` @ http://reluk.ca/project/Breccia/language_definition.brec
        - A representation of an aimed way of life.
        - A Waybreccian simulacrum.
    - It comprises a directory of files together with a data store, each file either originating
      in the waycast, lying on-way of it, or otherwise subsumed.
    - It results from compiling the waycast.
        : re `compiling` see `^^ Compilation$`

    !! This method of patch-based modelling has gone out of hand.
        : see @ ~/work/wayic/model/action_plan.brec
        archive the present files+ before rebasing on any new design
            : see @ ~/work/wayic/model/action_plan.brec



    ━━━━━━━━━━━━━
     Compilation
    ─────────────
        : cf. @ http://reluk.ca/project/Breccia/language_definition.brec
        - Compilation of a way model from a waycast.

        compile( waycast `w` )
            1. Copying of intracast files
                if( `w` contains at its base a file or directory named `:` )
                    throw+ Disallowed file name
                + Add to the model all files of `w`.
            2. Registration of subcasts
                deem+ `λ` the canonical location of the local waycast
                + Add `λ` to `λλ`.
                + Set the `local waycast register` of the data store
                  to `make register( local waycast, λ )`.
            3. Subsumption and patching of extracast files
                a) Explicitly via subsumers \ Before (b), while the model contains local subsumers only.
                    for( each subsumer `s` of the model  )
                        + `subsume and patch referent( URI of s )`
                            : see `^^subsume and patch referent\(` @ `^^ Subsumption$`
                b) Implicitly via way trace
                    deem+ `t` a thoroughfractum, that of the model
                    if( `t` is a jointer `j` )
                        + `subsume and patch through( j )`
                            : see `^^subsume and patch through\(` @ `^^ Subsumption$`
                    else
                        + `subsume and patch subjoints( t )`
                            : see `^^subsume and patch subjoints\(` @ `^^ Subsumption$`
            4. Internment of references
                : see also `(intern reference)` @ `^^subsume and patch through`
                for( each remote associative reference `rAR` of the model  )
                    if( `rAR` is without an `uninterned` qualifier )
                        deem+ `u` the URI of `rAR`;
                              `p` a file path, that of `intramodel path( standardize( u ))`
                                : re `intramodel path` see `^^intramodel path\(` @ `^^ Subsumption$`
                                : re `standardize`     see `^^standardize\(`     @ `^^ Subsumption$`
                        if( a file is present at `p` )
                            + `intern reference( rAR, u, p )`
                                : see `^^intern reference\(` @ `^^ Subsumption$`
            5. Compilation

        make register( waycast `w`, waycast canonical location `λ` )
            / Makes a complete waycast register for `w`.  Assumes that already `λλ` contains `λ`.
            deem+ `r` a new waycast register
            + Set the `location` of `r` to `λ`.
            for( each subcast `s` of `w` in priority order )
                + Set `λ` to the canonical location of `s`.
                unless( `λλ` contains `λ` )
                    + Add `λ` to `λλ`.
                    + Append `make register(s,λ)` to the `subcast registers` of `r`.
            return+ `r`



    ━━━━━━━━━━━━
     Data store
    ────────────
        λλ
            - The set of canonical locations of registered waycasts.
                : see `^^location` @ `^^waycast register$`
            / Initial value, empty.
        local waycast register
            - The waycast register of the local waycast.
            / Initial value, null.
        stray references
            - The set of associative references each of which retains its original, uninterned form
              only because an internment attempt had failed to find its referent
              in the subsumed instance of the referent file.
                / E.g. because patches targeting the referent file have been suppressed.
                / Initial value, empty.
            / The corresponding referents, lying outside the way model, are off-way by definition.



    ━━━━━━━━━━━━━━━━
     Data structure
    ────────────────
        waycast register
            - The register of a waycast `w`.
            - It defines the hierarchic order of waycasts (surcasts and subcasts)
              that in turn governs the order of patch application.
            location, URI
                - The canonical location of `w`.
                : re `URI` see https://tools.ietf.org/html/rfc3986#section-3
                / Initial value, null.
                - All locations within the register, including that of `w` and each of its subcasts,
                  whether direct or indirect, are unique.
            subcast registers, list of waycast registers
                - The registers of the subcasts of `w` in priority order, highest first.
                / Initial value, empty.



    ━━━━━━━━━━━━━━━━━━━
     Patch application
    ───────────────────
        - Subsumed files alone are patched, each immediately on its subsumption.
            : re `^^Subsumed files alone$` see `^^\`self targeting\`$` @ `^^ patch suppression$`
        - Patches are applied to the file in a hierarchic order derived from the waycast registers `wR`,
          beginning with that of the local waycast.
            : re `that of the local waycast` see `^^local waycast register$`
            a) First to apply are the patches of the subcast registers of `wR`.
                : see `^^subcast registers` @ `^^waycast register$`
            b) Last to apply are the patches of the `wR` waycast itself.
        - This order recurses at step (a), wherein both steps (a, b) repeat for each subcast register
          (itself now `wR`) in turn.
            / In terms of tree structures, this is a depth-first post-order traversal.

        apply patches( subsumed path `t` of the target file,  waycast `w` )
            for( each Breccian file `f` of `w` in standard path order )
                for( each patch `p` of `f` in linear order )
                    if( the target of `p` has the same canonical location as the original of `t` )
                        : see `The.+components of the subsumed file.+are.+of its canonical location`
                          @ `^^ Subsumption$`
                        + `apply( p, t )`
                            : see `^^apply\(` @ `^^ Patch$` @
                              http://reluk.ca/project/wayic/Waybrec/language_definition.brec

        apply patches( subsumed path `t` of the target file,  waycast `w`,  waycast register `wR` )
            / Returns true if target `t` is native to `w` or a registered subcast of `w`.
            deem+ `isSelfOwned` a boolean flag telling whether `t` is native to `w`;
                  `isRegistrantOwned` a boolean flag, initially false, to tell whether `t`
                     is native to `w` or a registered subcast of `w`;
                  `cS` a cause of patch suppression, initially null
            a) Patches of the registered subcasts of `w`
                if( `isSelfOwned` )
                    + Set `isRegistrantOwned` to true.
                    + Set `cS` to `surcast targeting`.
                for( each waycast register `sR` of the `subcast registers` of `wR` )
                    deem+ `s` the waycast at `sR.location`
                    if( `cS` is null )
                        + Set `isRegistrantOwned` to `apply patches( t, s, sR )`.
                        if( `isRegistrantOwned` )
                            + Set `cS` to `prior-branch targeting`.
                    else
                        + `record suppression of any patches( t, s, cS, sR )`
            b) Patches of `w` itself
                if( not `isSelfOwned` )
                    if( `isRegistrantOwned` )
                        + `apply patches( t, w )`
                    else \ [native dormancy], q.v. at end note
                        + `record suppression of any patches( t, w, native dormancy )`
                            : re `native dormancy` see `^^determination of native dormancy` @ `^^ Note$`
                else
                    + `record suppression of any patches( t, w, self targeting )`
            return+ `isRegistrantOwned`

        standard path order
            - An arrangement among file paths determined by applying the Unicode Collation Algorithm
              to their string representations.
                : re `^^Unicode Collation Algorithm$` see https://unicode.org/reports/tr10/
                : re `^^Unicode Collation Algorithm$` e.g. http://site.icu-project.org/
            - How to apply this algorithm (e.g. language and other customizations) is yet undefined.
                / It may require formalizing a locale property for the waycast.


        ───────────────────
         patch suppression
        ┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈
            - The application of a patch may be suppressed owing to one of several causes,
              which are formalized as follows.

                `native dormancy`
                    - The patch has no effect in the model of its native waycast,
                      because there its target is unsubsumed.
                        : see `Patches whose targets fall within the way model alone are applied` @
                          http://reluk.ca/project/wayic/Waybrec/language_definition.brec
                    - Likely it was subsumed in the past, then disappeared and left the patch
                      lying dormant there, its target now out of reach.
                    - The target reappears here in the present model, but rather than activate and apply
                      to it a patch which has lain dormant and probably unmaintained in its native model,
                      the patch is here suppressed.
                `prior-branch targeting`
                    - The patch targets a file native to a waycast registered in a prior branch
                      of the register hierarchy.
                    - A surcast has registered the present branch at a lower priority.
                        - Typically this occurs when the surcaster has surjoined a new subcast
                          and must therefore assign it a priority.
                        - Often he assigns a lower priority in the hope of gaining from the subcast
                          what he sees in it, while suffering no unexpected (and often unseen) loss
                          as a side effect of its patches.
                    - For this reason the patch is suppressed by default.
                      It targets a file which the surcaster may prefer to leave unaltered.
                `self targeting`
                    - The patch targets a file of its own waycast.
                    - This causes a compilation error, in fact, not a patch suppression.
                        / It is included here only because of its similarity
                          to the other ‘targeting’ causes.
                        : re `compilation error` e.g. `^^throw. Patch.+ targets.+its own waycast` @
                          `^^record suppression of patch\($`
                `surcast targeting`
                    - The patch targets a file native to a surcast.
                    - For this reason the patch is suppressed by default.  It targets a file which
                      the surcaster may prefer to leave unaltered, especially without prior notice.

            record suppression of any patches( subsumed path `t` of the target file,  waycast `w`,
                      cause of suppression `cS` )
                for( each Breccian file `f` of `w` in standard path order )
                    for( each patch `p` of `f` in linear order )
                        if( the target of `p` has the same canonical location as the original of `t` )
                            : see `The.+components of the subsumed file.+are.+of its canonical location`
                              @ `^^ Subsumption$`
                            + `record record suppression of patch( t, w, cS, p )`

            record suppression of any patches( subsumed path `t` of the target file,  waycast `w`,
                      cause of suppression `cS`, waycast register `wR` )
                a) Patches of the registered subcasts of `w`
                    for( each waycast register `sR` of the `subcast registers` of `wR` )
                        deem+ `s` the waycast at `sR.location`
                        + `record suppression of any patches( t, s, cS, sR )`
                b) Patches of `w` itself
                    + `record suppression of any patches( t, w, cS )`

            record suppression of patch( subsumed path `t` of the target file,  waycast `w`,
                      cause of suppression `cS`, patch `p` )
                if( `cS` equals `self targeting` )
                    throw+ Patch `p` targets file `t` of its own waycast `w`
                        : see `target must lie.+remote` @ `^^ Patch$` @
                          http://reluk.ca/project/wayic/Waybrec/language_definition.brec
                + Record for the user a message that the application of patch `p` native of `w`
                  to target `t` has been suppressed owing to cause `cS`.
                    / Compilers may include further data (e.g. attached to `cS`)
                      in order to form a message helpful to the user.



    ━━━━━━━━━━━━━
     Subsumption
    ─────────────
        - All extracast files of a way model are copied and stored within the model (subsumed)
          at a path formed as follows.

              ╶──╴‘:/’╶── authority ── path ───▶

                : re `authority` see https://tools.ietf.org/html/rfc3986#section-3.2
                : re `path` see https://tools.ietf.org/html/rfc3986#section-3.3
            - The authority and path components of the subsumed file
              are those of its canonical location as expressed in URI form.
                : re `URI form` see https://tools.ietf.org/html/rfc3986#section-3
            / Omitted is the scheme component of the canonical location, which compilers and other
              processors may recover ad hoc through a process of trial and error discovery.
        - Subsumption serves several purposes, which include the following.
            • Collation of the way model from scattered waysource.
            • Patching of waysource that would otherwise be out of reach.
            • Ease of surjoining public way models, or otherwise referring into them.
                : see `^^- A public way model .+ to which other waysource may refer\.$`
        - A public way model includes its subsumptions, to which other waysource may refer.
            / For example, `http://reluk.ca/project/waycast/:/cleo.abacus.au/walt/waycast/foo.brec`.
            - The referent, in that case, would be the file as it appears (as it is patched, that is)
              in the subsuming way model (S).
                / So (to continue the example) file `https://cleo.abacus.au/walt/waycast/foo.brec`
                  as it appears in model `http://reluk.ca/project/waycast/`.
            - Compiling a jointer to such a file would subsume the file from its native waycast
              and apply to it (subject to patch suppression) the patches of S.
        - Regardless of the form of jointing to an extracast file, whether to the original in its native
          waycast, a duplicate in that waycast’s public model (M), or its remote subsumption in another
          model (S) — any number of which may be combined in the waysource — the following hold true.
            • The way model subsumes a single intramodel instance of the file, to which all references
              (where not precluded by model divergence or explicit exemption) are transformed (interned).
                : re `intramodel instance` see `^^intramodel path\(`
                : re `model divergence` see `^^stray references$` @ `^^ Data store$`
                : re `explicit exemption` see `^^uninterned` @
                  http://reluk.ca/project/wayic/refractory/index.brec
            • The way model requires that M be registered as a subcast of the model, meaning that M must
              be declared as a subcast either by the local waycast, or by an already registered subcast.
            • The way model inherits the patches of M and applies them (subject to patch suppression)
              wherever they find their targets among the subsumed files of the model.
        - Additionally, for any jointer to a remote subsumption of the file in S:
            • The way model requires, likewise, that S be registered as a subcast.
                : cf. `^^• The way model requires that M be registered as a subcast`
            • The way model inherits the patches of S.
                : cf. `^^• The way model inherits the patches of M`

        intern reference( remote associative reference `rA` of the model,
              URI `u` equal to the URI reference of the resource indicator of `rA`,
              path `p` of the intramodel instance of the referent of `u` )
                : re `(URI) \`u\`` see https://tools.ietf.org/html/rfc3986#section-3
            / Attempts to transform `rA` within the model to refer instead to `p`.
              Returns `(rA2, wasInterned)`, the result `rA2` plus boolean flag `wasInterned`.
              The flag will be false if internment failed, in which case `rA2` will equal `rA`
              and will have been added to the data store’s stray references.
            deem+ `isSubsumption` a boolean flag telling whether `p` is a subsumption path
                : re `subsumption path` see `are .+subsumed.+\R.+at a path formed as follows`
            if( `isSubsumption`  &&  already `rA` is present in the stray references of the data store )
                return+ `(rA, false)`
            deem+ `rAL` an associative reference, intially equal in form to `rA`;
                  `wasInterned` a boolean flag, initially false
            + Transform `rAL` by setting its resource indicator’s URI reference (presently `u`)
              to the relative path from the file of `rA` to that of `p`.
            if( `isSubsumption` )
                try
                    + `referent( rAL )`
                        : see `^^referent\( associative reference \)` @
                          http://reluk.ca/project/Breccia/language_definition.brec
                catch( broken reference, pattern not found )
                    + Add `rA` to the stray references of the data store.
                    + Warn of `(rA, u)`, ‘Stray reference `rA`: its referent could not be found
                      in the subsumed instance of its referent file `u`, and therefore `rA`
                      is left uninterned, referring outside the way model.’
                    return+ `(rA, false)`
            + Write `rAL` into the model in place of `rA`.
            + Set `wasInterned` to true.
            return+ `(rAL, wasInterned)`

        intramodel path( standardized URI `u` )
            : re `standardized` see `^^standardized\(`
            : re `URI` see https://tools.ietf.org/html/rfc3986#section-3
            / The path proper to any intramodel instance of the referent of `u`.
                : re `intramodel instance` see @ `^^- Regardless of the various forms of reference`
            if( `u` begins with the canonical location `λ` of the local waycast )
                return+ `u` relativized against `λ`
            return+ the subsumption path derived from `u`
                : re `subsumption path` see `are .+subsumed.+\R.+at a path formed as follows`

        standardize( URI `u` )
            : re `URI` see https://tools.ietf.org/html/rfc3986#section-3
            / Returns the standard form of `u` for subsumption purposes.
            if( `u` lacks an authority component )
                throw+ Malformed reference
            if( `u` contains a subsumption path )
                : re `subsumption path` see `are .+subsumed.+\R.+at a path formed as follows`
                + Set `u` to the native location of the subsumed file.
                    \ Now `u` *should* be in standard form.  But that, of course, does not suffice.
            if( `u` refers to a waycast file )
                + Set `u` to `canonicalize( u )`.
                    : re `canonicalize` see `canonicalize\( URI` @ `^^ Canonical location$` @
                      http://reluk.ca/project/wayic/cast/form_of_a_waycast.brec
            else
                + Set `u` to normal form.
                    : see https://tools.ietf.org/html/rfc3986#section-6
            return+ `u`

        subsume and patch referent( URI `u` )
            : re `URI` see https://tools.ietf.org/html/rfc3986#section-3
            / Subsumes and patches the referent of `u` unless it is proper to the waycast
              or was already subsumed.  Returns the value of `intramodel path( u )`.
            deem+ `f` a file path;
                  `λ` the location of a waycast;
                  `uS` a standardized URI
            if( `u` contains a subsumption path )
                : re `subsumption path` see `are .+subsumed.+\R.+at a path formed as follows`
                + Set `λ` to the location of the subsuming way model of `u`.
                + Set `λ` to `canonicalize( λ )`.
                    : re `canonicalize` see `canonicalize\( URI` @ `^^ Canonical location$` @
                      http://reluk.ca/project/wayic/cast/form_of_a_waycast.brec
                unless( `λλ` contains `λ` )
                    throw+ Attempt to subsume file `u` through a model of waycast `λ`,
                      unregistered as a subcast
            + Set `uS` to `standardize( u )`.
            + Set `f` to `intramodel path( uS )`.
            if( `f` is a subsumption path  &  no file is present at `f` )
                : re `subsumption path` see `are .+subsumed.+\R.+at a path formed as follows`
                if( `uS` refers to a waycast file )
                    + Set `λ` to the waycast location of `uS`.
                    unless( `λλ` contains `λ` )
                        throw+ Attempt to subsume file `u` native of waycast `λ`,
                          unregistered as a subcast
                if( the referent of `u` is a directory )
                    throw+ Unable to subsume referent: directory `u`
                + Copy the referent of `u` to `f`.
                for( each relative URI reference `r` in the copy )
                    + Replace `r` with an absolute reference, that of `r` resolved against `u`.
                + `apply patches( f, local waycast, local waycast register )`
                    : see `^^apply patches\( subsumed file path.+waycast register` @
                      `^^ Patch application$`
            return+ `f`

        subsume and patch subjoints( fractum `f` of the model )
            / Ensures that the subsumable files of all fracta subjoint of `f` are subsumed and patched.
            for( each jointer `j` descendent of `f` )
                + `subsume and patch through( j )`
                    / Here compilers should detect and avoid any infinite loop.

        subsume and patch through( jointer `j` of the model )
            / Ensures that the files of all fracta subjoint and subsumable by way of `j`
              are indeed subsumed and patched.
            if( `j` has a resource indicant `iR` )
                if( `iR` has either a `non-fractal` or an `uninterned` qualifier )
                    return+
                if( `iR` is a remote resource indicant )
                    deem+ `u` the URI of `iR`;
                          `p` a file path, that of `subsume and patch referent( u )`;
                          `wasInterned` a boolean flag
                    + Set `(j, wasInterned)` to `intern reference( j, u, p )`.
                    unless( wasInterned )
                        return+
            deem+ `f` a fractum;
                  `t` a referent
            + Set `t` to `referent( j )`.
                : re `referent` see `^^referent\( associative reference \)` @
                  http://reluk.ca/project/Breccia/language_definition.brec
            if( `t` is a fractal-head text sequence )
                + Set `f` to the fractum of the head in which `t` occurs.
            else
                / Then `t` can only be a fractum. \ ∵ `non-fractal` is absent
                + Set `f` to `t`.
            / Fractum `f` lies within the model. \ ∵ any `u` above was subsumed to a relative reference
            + `subsume and patch subjoints( f )`



    ━━━━━━
     Note
    ──────
        determination of native dormancy
            - No registered subcast of `w` owns target file `t` in the present model.
                ∵ `isRegistrantOwned` is false.
            ∴ No registered subcast in the model of `w` owns `t`.
                ∵ Otherwise, in the present model, that subcast (here unregistered for `w`) must instead
                  be registered for a surcast or waycast of a prior branch of the register hierarchy,
                  in which case this point in the compilation process would never have been reached.
                    ∵ Rather than `apply patches` of `w`, the compiler would have suppressed their
                      application for the cause of `surcast targeting` or `prior-branch targeting`.
            ∴ File `t` in the model of `w` would be unsubsumed.
                ∵ Subsumption of any file depends on its native waycast being registered as a subcast.
                    : see `^^throw.+native of waycast.+\R.+unregistered as a subcast$` @
                      `^^subsume and patch referent\(`
            ∴ The model of `w` would apply to `t` no patch.
            ∴ The model of `w` would apply to `t` no patch declared by `w`.
              Such a patch would, in other words, lie dormant in its native model.
            ∴ Application of all such patches is here suppressed for the cause of `native dormancy`.



                                                    \ Copyright © 2020-2021  Michael Allan.  Licence MIT.
