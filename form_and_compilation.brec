Form and compilation of way models

    - A way model is a waycast in compiled, executable form,
      as opposed to the initial, written form of its source code.
        : cf. `^^ Simulacrum$` @ http://reluk.ca/project/Breccia/language_definition.brec
        - A representation of an aimed way of life.
        - A Waybreccian simulacrum.
    - It comprises a directory of files together with a data store, each file either originating
      in the waycast, lying on-way of it, or otherwise subsumed.
    - It results from compiling the waycast.
        : re `compiling` see `^^ Compilation$`



    ━━━━━━━━━━━━━
     Compilation
    ─────────────
        : cf. @ http://reluk.ca/project/Breccia/language_definition.brec
        - Compilation of a way model from a waycast.

        compile( waycast `w` )
            : join `^^simulacral reference$` @ `^^ Note$`
            0. Copying of intracast files
                if( `w` contains at its base a file or directory named `:` )
                    throw+ Disallowed file name
                + Add to the model all files of `w`.
            1. Subsumption of extracast files
                a) Explicitly via subsumers \ Before (b), while the model contains local subsumers only.
                    for( each subsumer `s` of the model  )
                        + `subsume referent( URI of s )`
                            : see `^^subsume referent\(` @ `^^ Subsumption$`
                b) Implicitly via way trace
                    deem+ `t` a thoroughfractum, that of the model
                    if( `t` is a jointer `j` )
                        + `subsume through( j )`
                            : see `^^subsume through\(` @ `^^ Subsumption$`
                    else
                        + `subsume subjoints( t )`
                            : see `^^subsume subjoints\(` @ `^^ Subsumption$`
            2. Internment of references
                : see also `(intern reference)` @ `^^subsume through`
                for( each associative reference `rA` of the model  )
                    if( `rA` has a resource indicant `iR`,
                      & `iR` is without an `uninterned` qualifier,
                      & the URI reference of `iR` is a proper URI `u` )
                        : re `proper URI` see https://tools.ietf.org/html/rfc3986#section-3
                        deem+ `p` a file path, that of `intramodel path( u )`
                        if( a file is present at `p` )
                            + `intern reference( rA, u, p )`
            3. Patching
            4. Compilation

        order by path( list of file paths `pp` )
            + Sort `pp` into lexicographic order based on Unicode code points.
            return+ `pp`



    ━━━━━━━━━━━━
     Data store
    ────────────
        loose references
            - The set of associative references each of which failed to subsume because its referent
              could not be found in the subsumed instance of the referent file.
                / This may occur, for instance, when conflict resolution has pre-emptively disabled
                  one or more patches that would have applied to subsumed instance of the referent file.
            / The corresponding referents, lying outside the way model, are off-way by definition.



    ━━━━━━━━━━━━
     Subsumption
    ────────────
        - All extracast files of a way model are copied and stored within the model (subsumed)
          at a path formed as follows.

              ╶──╴‘:/’╶── authority ── path ───▶

                : re `authority` see https://tools.ietf.org/html/rfc3986#section-3.2
                : re `path` see https://tools.ietf.org/html/rfc3986#section-3.3
            - The authority and path components of the subsumed file
              are those of its canonical location as expressed in URI form.
                : re `URI form` see https://tools.ietf.org/html/rfc3986#section-3
            / Omitted is the scheme component of the canonical location, which compilers and other
              processors may recover ad hoc through a process of trial and error discovery.
        - Subsumption serves several purposes, which include the following.
            • Collation of the way model from scattered waysource.
            • Patching of waysource that would otherwise be out of reach.
            • Ease of surjoining remote way models, or otherwise referring into them.
                : see `^^- A public way model .+ to which other waysource may refer\.$`
        - Regardless of the various forms of reference to an extracast file, whether to its original
          or a remote subsumption of it (any number of which may be combined in the waysource),
          the way model has at most one, intramodel instance of the file to which all such references
          (where not precluded by model divergence) are transformed (interned).
            : re `intramodel instance` see `^^intramodel path\( URI`
            : re `precluded by model divergence` see `^^loose references$` @ `^^ Data store$`
        - A public way model includes its subsumptions, to which other waysource may refer.
            / The following, for example, refers to a publicly subsumed file.
              http://reluk.ca/project/waycast/:/cleo.abacus.au/walt/waycast/foo.brec
            - The referent, in that case, would be the file as seen in the subsuming way model (M).
                / E.g. `https://cleo.abacus.au/walt/waycast/foo.brec`
                  as seen in `http://reluk.ca/project/waycast/`.
            - Compiling a jointer to such a referent would subsume the file from its original waycast,
              while applying (where conflict resolution allows) the patches of M.

        intern reference( internable associative reference `rA` of the model,
              URI `u` equal to the URI reference of the resource indicator of `rA`,
              path `p` of the intramodel instance of the referent of `u` )
                : re `(URI) \`u\`` see https://tools.ietf.org/html/rfc3986#section-3
            / Transforms `rA` to refer instead to `p`, then writes `rA` back into the model.
              Returns `(rA, wasInterned)`, the resulting associative reference `rA` plus boolean flag
              `wasInterned`.  The flag will be false if internment failed, in which case `rA` will have
              been added to the data store’s loose references and will retain its original form.
            deem+ `wasInterned` a boolean flag, initially false
            if( `p` is no subsumption path )
                : re `subsumption path` see `are .+subsumed.+ at a path formed as follows`
                + Transform `rA` by setting its resource indicator’s URI reference (presently `u`)
                  to the relative path from the file of `rA` to that of `p`. \ The same as below.
                + Write the transformed `rA` into the model, replacing its original instance.
                + Set `wasInterned` to true.
            else if( `rA` is absent from the loose references of the data store )
                + Transform `rA` by setting its resource indicator’s URI reference (presently `u`)
                  to the relative path from the file of `rA` to that of `p`. \ The same as above.
                try
                    + `referent( rA )`
                        : see `^^referent\( associative reference \)` @
                          http://reluk.ca/project/Breccia/language_definition.brec
                    + Write the transformed `rA` into the model, replacing its original instance.
                    + Set `wasInterned` to true.
                catch( broken reference, pattern not found )
                    + Revert `rA` to its original form by setting its resource indicator’s
                      URI reference back to `u`.
                    + Add `rA` to the loose references of the data store.
                    + Warn of `(rA, u)`, ‘Loose reference `rA`: its referent could not be found
                      in the subsumed instance of its referent file `u`, and therefore `rA`
                      is left uninterned, referring outside the way model.’
            return+ `(rA, wasInterned)`

        intramodel path( URI `u` )
            : re `URI` see https://tools.ietf.org/html/rfc3986#section-3
            / The path proper to any intramodel instance of the referent of `u`.
                : re `intramodel instance` see @ `^^- Regardless of the various forms of reference`
            + Set `u` to `standardize( u )`.
            if( `u` begins with the canonical location `λ` of the local waycast )
                return+ `u` relativized against `λ`
            return+ the subsumption path derived from `u`
                : re `subsumption path` see `are .+subsumed.+ at a path formed as follows`

        standardize( URI `u` )
            : re `URI` see https://tools.ietf.org/html/rfc3986#section-3
            / Returns the standard form of `u` for subsumption purposes.
            if( `u` lacks an authority component )
                throw+ Malformed reference
            if( `u` refers to a waycast file )
                + Set `u` to `canonicalize( u )`.
                    : re `canonicalize` see `canonicalize\( URI` @ `^^ Canonical location$` @
                      http://reluk.ca/project/wayic/cast/form_of_a_waycast.brec
            else
                + Set `u` to normal form.
                    : see https://tools.ietf.org/html/rfc3986#section-6
            return+ `u`

        subsume referent( URI `u` )
            : re `URI` see https://tools.ietf.org/html/rfc3986#section-3
            / Subsumes the referent of `u` unless it is either local to the waycast or already subsumed.
              Returns the value of `intramodel path( u )`.
            deem+ `p` a file path, that of `intramodel path( u )`
            if( `p` is a subsumption path  &  no file is present at `p` )
                : re `subsumption path` see `are .+subsumed.+ at a path formed as follows`
                + Copy the referent of `u` to `p`.
                for( each relative URI reference `r` in the copy )
                    + Replace `r` with an absolute reference, that of `r` resolved against `u`.
            return+ `p`

        subsume subjoints( fractum `f` of the model )
            / Ensures that the subsumable files of all fracta subjoint of `f` are subsumed.
            for( each jointer `j` descendent of `f` )
                + `subsume through( j )`
                    / Here compilers should detect and avoid any infinite loop.

        subsume through( jointer `j` of the model )
            / Ensures that the subsumable files of all fracta subjoint through `j` are subsumed.
            if( `j` has a resource indicant `iR` )
                if( `iR` has either a `non-fractal` or an `uninterned` qualifier )
                    return+
                if( the URI reference of `iR` is a proper URI `u` )
                    : re `proper URI` see https://tools.ietf.org/html/rfc3986#section-3
                    deem+ `p` a file path;
                          `wasInterned` a boolean flag
                    + Set `p` to `subsume referent( u )`.
                    + Set `(j, wasInterned)` to `intern reference( j, u, p )`.
                    unless( wasInterned )
                        return+
            deem+ `f` a fractum;
                  `t` a referent
            + Set `t` to `referent( j )`.
                : re `referent` see `^^referent\( associative reference \)` @
                  http://reluk.ca/project/Breccia/language_definition.brec
            if( `t` is a fractal-head text sequence )
                + Set `f` to the fractum of the head in which `t` occurs.
            else
                / Then `t` can only be a fractum. \ ∵ `non-fractal` is absent
                + Set `f` to `t`.
            / Fractum `f` lies within the model. \ ∵ any `u` above was subsumed to a relative reference
            + `subsume subjoints( f )`



    ━━━━━━
     Note
    ──────
        simulacral reference
            - Herein the default referent is the simulacrum (aka the way model), not the source code.
                : cf. `^^default referent` @ `^^ Simulacrum$` @
                  http://reluk.ca/project/Breccia/language_definition.brec



                                                    \ Copyright © 2020-2021  Michael Allan.  Licence MIT.
