Form and compilation of way models

    - A way model is the compiled, executable form of a waycast,
      as opposed to the initial, written form of its source code.
        : cf. `^^ Simulacrum$` @ http://reluk.ca/project/Breccia/language_definition.brec
        - A representation of an aimed way of life.
        - A Waybreccian simulacrum.
    - It comprises a directory of files together with a data store, each file either originating
      in the waycast, lying on-way of it, or otherwise subsumed.
    - It results from compiling the waycast.
        : re `compiling` see `^^ Compilation$`



    ━━━━━━━━━━━━━
     Compilation
    ─────────────
        : cf. @ http://reluk.ca/project/Breccia/language_definition.brec
        - Compilation of a way model from a waycast.

        compile( waycast `w` )
            1. Copying of intracast files
                if( `w` contains at its base a file or directory named `:` )
                    throw+ Disallowed file name
                + Add to the model all files of `w`.
            2. Registration of subcasts
                deem+ `λ` the canonical location of the local waycast;
                      `λλ` a set of waycast locations, initially empty
                + Add `λ` to `λλ`.
                + Set the `local waycast register` of the data store
                  to `make register( local waycast, λ, λλ )`.
            3. Subsumption and patching of extracast files
                a) Explicitly via subsumers \ Before (b), while the model contains local subsumers only.
                    for( each subsumer `s` of the model  )
                        + `subsume and patch referent( URI of s )`
                            : see `^^subsume and patch referent\(` @ `^^ Subsumption$`
                b) Implicitly via way trace
                    deem+ `t` a thoroughfractum, that of the model
                    if( `t` is a jointer `j` )
                        + `subsume and patch through( j )`
                            : see `^^subsume and patch through\(` @ `^^ Subsumption$`
                    else
                        + `subsume and patch subjoints( t )`
                            : see `^^subsume and patch subjoints\(` @ `^^ Subsumption$`
            4. Internment of references
                : see also `(intern reference)` @ `^^subsume and patch through`
                for( each associative reference `rA` of the model  )
                    if( `rA` has a resource indicant `iR`,
                      & `iR` is without an `uninterned` qualifier,
                      & the URI reference of `iR` is a proper URI `u` )
                        : re `proper URI` see https://tools.ietf.org/html/rfc3986#section-3
                        deem+ `p` a file path, that of `intramodel path( u )`
                        if( a file is present at `p` )
                            + `intern reference( rA, u, p )`
            5. Compilation

        intern reference( internable associative reference `rA` of the model,
              URI `u` equal to the URI reference of the resource indicator of `rA`,
              path `p` of the intramodel instance of the referent of `u` )
                : re `(URI) \`u\`` see https://tools.ietf.org/html/rfc3986#section-3
            / Transforms `rA` to refer instead to `p`, then writes `rA` back into the model.
              Returns `(rA, wasInterned)`, the resulting associative reference `rA` plus boolean flag
              `wasInterned`.  The flag will be false if internment failed, in which case `rA` will have
              been added to the data store’s loose references and will retain its original form.
            deem+ `wasInterned` a boolean flag, initially false
            if( `p` is no subsumption path )
                : re `subsumption path` see `are .+subsumed.+ at a path formed as follows`
                + Transform `rA` by setting its resource indicator’s URI reference (presently `u`)
                  to the relative path from the file of `rA` to that of `p`. \ The same as below.
                + Write the transformed `rA` into the model, replacing its original instance.
                + Set `wasInterned` to true.
            else if( `rA` is absent from the loose references of the data store )
                + Transform `rA` by setting its resource indicator’s URI reference (presently `u`)
                  to the relative path from the file of `rA` to that of `p`. \ The same as above.
                try
                    + `referent( rA )`
                        : see `^^referent\( associative reference \)` @
                          http://reluk.ca/project/Breccia/language_definition.brec
                    + Write the transformed `rA` into the model, replacing its original instance.
                    + Set `wasInterned` to true.
                catch( broken reference, pattern not found )
                    + Revert `rA` to its original form by setting its resource indicator’s
                      URI reference back to `u`.
                    + Add `rA` to the loose references of the data store.
                    + Warn of `(rA, u)`, ‘Loose reference `rA`: its referent could not be found
                      in the subsumed instance of its referent file `u`, and therefore `rA`
                      is left uninterned, referring outside the way model.’
            return+ `(rA, wasInterned)`

        intramodel path( URI `u` )
            : re `URI` see https://tools.ietf.org/html/rfc3986#section-3
            / The path proper to any intramodel instance of the referent of `u`.
                : re `intramodel instance` see @ `^^- Regardless of the various forms of reference`
            + Set `u` to `standardize( u )`.
            if( `u` begins with the canonical location `λ` of the local waycast )
                return+ `u` relativized against `λ`
            return+ the subsumption path derived from `u`
                : re `subsumption path` see `are .+subsumed.+ at a path formed as follows`

        make register( waycast `w`, waycast canonical location `λ`, set of registered locations `λλ` )
            / Makes a complete waycast register for `w`.  Assumes that already `λλ` contains `λ`.
            deem+ `r` a new waycast register
            + Set the `location` of `r` to `λ`.
            for( each subcast `s` of `w` in priority order )
                + Set `λ` to the canonical location of `s`.
                unless( `λλ` contains `λ` )
                    + Add `λ` to `λλ`.
                    + Append `make register(s,λ,λλ)` to the `subcast registers` of `r`.
            return+ `r`

        standardize( URI `u` )
            : re `URI` see https://tools.ietf.org/html/rfc3986#section-3
            / Returns the standard form of `u` for subsumption purposes.
            if( `u` lacks an authority component )
                throw+ Malformed reference
            if( `u` refers to a waycast file )
                + Set `u` to `canonicalize( u )`.
                    : re `canonicalize` see `canonicalize\( URI` @ `^^ Canonical location$` @
                      http://reluk.ca/project/wayic/cast/form_of_a_waycast.brec
            else
                + Set `u` to normal form.
                    : see https://tools.ietf.org/html/rfc3986#section-6
            return+ `u`



    ━━━━━━━━━━━━
     Data store
    ────────────
        local waycast register
            - The waycast register of the local waycast.
            / Initial value, null.
        loose references
            - The set of associative references each of which failed to subsume because its referent
              could not be found in the subsumed instance of the referent file.
                / This may occur, for instance, when conflict resolution has pre-emptively disabled
                  one or more patches that would have applied to subsumed instance of the referent file.
                / Initial value, empty.
            / The corresponding referents, lying outside the way model, are off-way by definition.



    ━━━━━━━━━━━━━━━━
     Data structure
    ────────────────
        waycast register
            - The register of a waycast `w`.
            location, URI
                - The canonical location of `w`.
                : re `URI` see https://tools.ietf.org/html/rfc3986#section-3
                / Initial value, null.
                - All locations within the register, including that of `w` and each of its subcasts,
                  whether direct or indirect, are unique.
            subcast registers, list of waycast registers
                - The registers of the subcasts of `w` in priority order, highest first.
                / Initial value, empty.



    ━━━━━━━━━━
     Patching
    ──────────
        apply patches( subsumed file path `f`, waycast canonical location `λ` )
            deem+ `pp` a list of patches;
                  `w` the waycast at `λ`
            for( each Breccian file `g` of `w` in lexicographic path order )
                for( each patch `p` of `g` in linear order )
                    if( `p` targets `f` )
                        + Append `p` to `pp`.
            define the remainder+
                : cf. `^^apply\(` @ `^^ Patch$` @ ~/work/wayic/Waybrec/language_definition.brec

        apply patches( subsumed file path `f`, waycast register `r` )
            deem+ `ss` a list of waycast registers, that of the `subcast registers` of `r`
            for( each subcast register `s` of `ss` )
                + `apply patches( f, s.location )`
            + `apply patches( f, r.location )`



    ━━━━━━━━━━━━━
     Subsumption
    ─────────────
        - All extracast files of a way model are copied and stored within the model (subsumed)
          at a path formed as follows.

              ╶──╴‘:/’╶── authority ── path ───▶

                : re `authority` see https://tools.ietf.org/html/rfc3986#section-3.2
                : re `path` see https://tools.ietf.org/html/rfc3986#section-3.3
            - The authority and path components of the subsumed file
              are those of its canonical location as expressed in URI form.
                : re `URI form` see https://tools.ietf.org/html/rfc3986#section-3
            / Omitted is the scheme component of the canonical location, which compilers and other
              processors may recover ad hoc through a process of trial and error discovery.
        - Subsumption serves several purposes, which include the following.
            • Collation of the way model from scattered waysource.
            • Patching of waysource that would otherwise be out of reach.
            • Ease of surjoining remote way models, or otherwise referring into them.
                : see `^^- A public way model .+ to which other waysource may refer\.$`
        - Regardless of the various forms of reference to an extracast file, whether to its original
          or a remote subsumption of it (any number of which may be combined in the waysource),
          the way model has at most one, intramodel instance of the file to which all such references
          (where not precluded by model divergence) are transformed (interned).
            : re `intramodel instance` see `^^intramodel path\(` @ `^^ Compilation$`
            : re `precluded by model divergence` see `^^loose references$` @ `^^ Data store$`
        - A public way model includes its subsumptions, to which other waysource may refer.
            / The following, for example, refers to a publicly subsumed file.
              http://reluk.ca/project/waycast/:/cleo.abacus.au/walt/waycast/foo.brec
            - The referent, in that case, would be the file as seen in the subsuming way model (M).
                / E.g. `https://cleo.abacus.au/walt/waycast/foo.brec`
                  as seen in `http://reluk.ca/project/waycast/`.
            - Compiling a jointer to such a referent would subsume the file from its original waycast,
              while applying (where conflict resolution allows) the patches of M.

        subsume and patch referent( URI `u` )
            : re `URI` see https://tools.ietf.org/html/rfc3986#section-3
            / Subsumes and patches the referent of `u` unless it is proper to the waycast
              or was already subsumed.  Returns the value of `intramodel path( u )`.
                : re `intramodel path` see `^^intramodel path\(` @ `^^ Compilation$`
            deem+ `f` a file path, that of `intramodel path( u )`
                : see `^^intramodel path\(` @ `^^ Compilation$`
            if( `f` is a subsumption path  &  no file is present at `f` )
                : re `subsumption path` see `are .+subsumed.+ at a path formed as follows`
                + Copy the referent of `u` to `f`.
                for( each relative URI reference `r` in the copy )
                    + Replace `r` with an absolute reference, that of `r` resolved against `u`.
                + `apply patches( f, local waycast register )`
                    : see `^^patch\(` @ `^^ Patching$`
            return+ `f`

        subsume and patch subjoints( fractum `f` of the model )
            / Ensures that the subsumable files of all fracta subjoint of `f` are subsumed and patched.
            for( each jointer `j` descendent of `f` )
                + `subsume and patch through( j )`
                    / Here compilers should detect and avoid any infinite loop.

        subsume and patch through( jointer `j` of the model )
            / Ensures that the files of all fracta subjoint and subsumable by way of `j`
              are indeed subsumed and patched.
            if( `j` has a resource indicant `iR` )
                if( `iR` has either a `non-fractal` or an `uninterned` qualifier )
                    return+
                if( the URI reference of `iR` is a proper URI `u` )
                    : re `proper URI` see https://tools.ietf.org/html/rfc3986#section-3
                    deem+ `p` a file path;
                          `wasInterned` a boolean flag
                    + Set `p` to `subsume and patch referent( u )`.
                    + Set `(j, wasInterned)` to `intern reference( j, u, p )`.
                        : see `^^intern reference\(` @ `^^ Compilation$`
                    unless( wasInterned )
                        return+
            deem+ `f` a fractum;
                  `t` a referent
            + Set `t` to `referent( j )`.
                : re `referent` see `^^referent\( associative reference \)` @
                  http://reluk.ca/project/Breccia/language_definition.brec
            if( `t` is a fractal-head text sequence )
                + Set `f` to the fractum of the head in which `t` occurs.
            else
                / Then `t` can only be a fractum. \ ∵ `non-fractal` is absent
                + Set `f` to `t`.
            / Fractum `f` lies within the model. \ ∵ any `u` above was subsumed to a relative reference
            + `subsume and patch subjoints( f )`



                                                    \ Copyright © 2020-2021  Michael Allan.  Licence MIT.
